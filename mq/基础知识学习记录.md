### 消息队列涉及知识

![image-20200821192824091](assets/image-20200821192824091.png)

### 消息队列问题

- 引入消息队列带来的延迟问题；
- 增加了系统的复杂度；
- 可能产生数据不一致的问题。

### 秒杀系统

**使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的**

<img src="assets/image-20200821195244942.png" alt="image-20200821195244942" style="zoom: 50%;" />

- 异步处理
- 流量限制
- 服务解耦
- 

**令牌桶控制流量的原理是： 单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。**（参考实现：https://blog.csdn.net/king0406/article/details/103129063）

<img src="assets/image-20200821195911097.png" alt="image-20200821195911097" style="zoom: 50%;" />

### 延迟任务

Note: silvan bullet, 万金油

### 消息队列选型

- 消息的可靠传递：确保不丢消息；
- Cluster：支持集群，确保不会因为某个节点宕机导致服务不可用，当然也不能丢消息；
- 性能：具备足够好的性能，能满足绝大多数场景的性能要求。
- **选择中间件的考量维度：可靠性，性能，功能，可运维行，可拓展性，是否开源及社区活跃度***

#### rabbitmq

- 对消息堆积支持不友好
- 性能相对来说不是最好
- 内核的语言相对小众erlang

#### rocketmq

- 不错的性能，稳定性和可靠性
- RocketMQ 对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，如果你的应用场景很在意响应时延，那应该选择使用 RocketMQ
- 每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。
- **每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。**需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。
- 

#### kafka

- 可靠性、稳定性和功能特性等方面都可以满足绝大多数场景的需求
- Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka
- Kafka 不太适合在线业务场景

### topic与queue区别

- publish-subscribe pattern

<img src="assets/image-20200821205120844.png" alt="image-20200821205120844" style="zoom: 50%;" />

- 它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。

- rabbitmq没有topic模型，而是使用队列模型，至于多个消费者需要消费消息，通过exchange配置路由目的队列实现。同一份消息如果需要被多个消费者来消费，需要配置 Exchange 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。

  <img src="assets/image-20200821205626893.png" alt="image-20200821205626893" style="zoom:50%;" />

- rocketmq 消息模型

  <img src="assets/image-20200821210426426.png" alt="image-20200821210426426" style="zoom:67%;" />

### 消息队列中的事务（分布式事务）

- **消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题。**

  ### 分布式事务基本特征

  一个严格意义的事务实现，应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

  - **原子性**，是指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况。

  - **一致性**，是指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据。

  - **隔离性**，是指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰，这个有点儿像我们打网游中的副本，我们在副本中打的怪和掉的装备，与其他副本没有任何关联也不会互相影响。

  - **持久性**，是指一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响。

####  kafka事务执行流程图

<img src="assets/image-20200821213708653.png" alt="image-20200821213708653" style="zoom:50%;" />

- **半消息***：消息发送之后消费者看不到，订单系统处理之后执行commit之后，购物车系统才可以看到对应的消息
- 如果第4步执行提交失败之后，kafka直接抛出异常，客户端需要处理

##### rocketmq执行事务流程

![image-20200821214122302](assets/image-20200821214122302.png)

### rabbitmq实现事务

- https://www.rabbitmq.com/semantics.html



### 消息丢失

- 识别消息丢失

  - 使用拦截器在每个消息加上编号，在消费者端通过检测编号连续来检查是否丢失数据

- 生产到消费阶段

  <img src="assets/image-20200821220155791.png" alt="image-20200821220155791" style="zoom:50%;" />

- 发送阶段

  - 发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失
  - 同步发送时，只要注意捕获异常即可
  - 异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。

- 