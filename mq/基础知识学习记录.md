### 消息队列涉及知识

- 必读文章：https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying

![image-20200821192824091](assets/image-20200821192824091.png)

### 消息队列问题

- 引入消息队列带来的延迟问题；
- 增加了系统的复杂度；
- 可能产生数据不一致的问题。

### 秒杀系统

**使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的**

<img src="assets/image-20200821195244942.png" alt="image-20200821195244942" style="zoom: 50%;" />

- 异步处理
- 流量限制
- 服务解耦
- 

**令牌桶控制流量的原理是： 单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须先从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就保证单位时间内，能处理的请求不超过发放令牌的数量，起到了流量控制的作用。**（参考实现：https://blog.csdn.net/king0406/article/details/103129063）

<img src="assets/image-20200821195911097.png" alt="image-20200821195911097" style="zoom: 50%;" />

### 延迟任务

Note: silvan bullet, 万金油

### 消息队列选型

- 消息的可靠传递：确保不丢消息；
- Cluster：支持集群，确保不会因为某个节点宕机导致服务不可用，当然也不能丢消息；
- 性能：具备足够好的性能，能满足绝大多数场景的性能要求。
- **选择中间件的考量维度：可靠性，性能，功能，可运维行，可拓展性，是否开源及社区活跃度***

#### rabbitmq

- 对消息堆积支持不友好
- 性能相对来说不是最好
- 内核的语言相对小众erlang

#### rocketmq

- 不错的性能，稳定性和可靠性
- RocketMQ 对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，如果你的应用场景很在意响应时延，那应该选择使用 RocketMQ
- 每个主题在任意时刻，至多只能有一个消费者实例在进行消费，那就没法通过水平扩展消费者的数量来提升消费端总体的消费性能。为了解决这个问题，RocketMQ 在主题下面增加了队列的概念。
- **每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。**需要注意的是，RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。
- 

#### kafka

- 可靠性、稳定性和功能特性等方面都可以满足绝大多数场景的需求
- Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka
- Kafka 不太适合在线业务场景

### topic与queue区别

- publish-subscribe pattern

<img src="assets/image-20200821205120844.png" alt="image-20200821205120844" style="zoom: 50%;" />

- 它们最大的区别其实就是，一份消息数据能不能被消费多次的问题。

- rabbitmq没有topic模型，而是使用队列模型，至于多个消费者需要消费消息，通过exchange配置路由目的队列实现。同一份消息如果需要被多个消费者来消费，需要配置 Exchange 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。

  <img src="assets/image-20200821205626893.png" alt="image-20200821205626893" style="zoom:50%;" />

- rocketmq 消息模型

  <img src="assets/image-20200821210426426.png" alt="image-20200821210426426" style="zoom:67%;" />

### 消息队列中的事务（分布式事务）

- **消息队列中的“事务”，主要解决的是消息生产者和消息消费者的数据一致性问题。**

  ### 分布式事务基本特征

  一个严格意义的事务实现，应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

  - **原子性**，是指一个事务操作不可分割，要么成功，要么失败，不能有一半成功一半失败的情况。

  - **一致性**，是指这些数据在事务执行完成这个时间点之前，读到的一定是更新前的数据，之后读到的一定是更新后的数据，不应该存在一个时刻，让用户读到更新过程中的数据。

  - **隔离性**，是指一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对正在进行的其他事务是隔离的，并发执行的各个事务之间不能互相干扰，这个有点儿像我们打网游中的副本，我们在副本中打的怪和掉的装备，与其他副本没有任何关联也不会互相影响。

  - **持久性**，是指一个事务一旦完成提交，后续的其他操作和故障都不会对事务的结果产生任何影响。

####  kafka事务执行流程图

<img src="assets/image-20200821213708653.png" alt="image-20200821213708653" style="zoom:50%;" />

- **半消息***：消息发送之后消费者看不到，订单系统处理之后执行commit之后，购物车系统才可以看到对应的消息
- 如果第4步执行提交失败之后，kafka直接抛出异常，客户端需要处理

##### rocketmq执行事务流程

![image-20200821214122302](assets/image-20200821214122302.png)

### rabbitmq实现事务

- https://www.rabbitmq.com/semantics.html



### 消息丢失

- 识别消息丢失

  - 使用拦截器在每个消息加上编号，在消费者端通过检测编号连续来检查是否丢失数据

- 生产到消费阶段

  <img src="assets/image-20200821220155791.png" alt="image-20200821220155791" style="zoom:50%;" />

- 发送阶段

  - 发送消息代码时，需要注意，正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失
  - 同步发送时，只要注意捕获异常即可
  - 异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，很多丢消息的原因就是，我们使用了异步发送，却没有在回调中检查发送结果。

- 存储阶段

  - 消息落盘，保证broker 宕机消息也不丢失。




### 重复消费

- **At most once**: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，允许丢消息。一般都是一些对消息可靠性要求不太高的监控场景使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。
- **At least once**: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消息，但是允许有少量重复消息出现。
- **Exactly once**：恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高的等级。

**设计幂等操作**

- 利用数据库的唯一约束实现幂等

- 为更新的数据设置前置条件

- 记录并检查操作

  记录并检查操作，也称为“Token 机制或者 GUID（全局唯一 ID）机制”，实现的思路特别简单：在执行数据更新操作之前，先检查一下是否执行过这个更新操作。在发送消息时，给每条消息指定一个全局唯一的 ID，消费时，先根据这个 ID 检查这条消息是否有被消费过，如果没有消费过，才更新数据，然后将消费状态置为已消费。



### 消息堆积额

- 发送端
  - 对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能
  - 消息发送流程
    - 发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时；
    - 发送消息和返回响应在网络传输中的耗时；
    - Broker 处理消息的时延。
  - 
- 消费端
  - 我们在设计系统的时候，一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。
  - **在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。**如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。
- 能导致积压突然增加，最粗粒度的原因，只有两种：要么是发送变快了，要么是消费变慢了



### 异步提高吞吐率

- java： CompletableFuture 
- 