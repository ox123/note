### redis全景图

<img src="assets/image-20200823122847275.png" alt="image-20200823122847275" style="zoom:50%;" />

- 应用维度

  - 应用场景驱动
  - 典型案例驱动

- 问题画像图

  <img src="assets/image-20200823123231761.png" alt="image-20200823123231761" style="zoom:50%;" />

- simple kv设计

  <img src="assets/image-20200823124913530.png" alt="image-20200823124913530" style="zoom: 33%;" /><img src="assets/image-20200823124936136.png" alt="image-20200823124936136" style="zoom:50%;" />

  <img src="assets/image-20200823124913530.png" alt="image-20200823124913530" style="zoom: 33%;" />![image-20200823124936136](assets/image-20200823124936136.png)




### redis 类型与数据结构对应关系

<img src="assets/image-20200914221809451.png" alt="image-20200914221809451" style="zoom:50%;" />

### Redis 基本IO模型

<img src="assets/image-20200920232759073.png" alt="image-20200920232759073" style="zoom: 50%;" />![image-20200920232845247](assets/image-20200920232845247.png)

<img src="assets/image-20200920233050948.png" alt="image-20200920233050948" style="zoom:50%;" />

- **selectepoll提供了基于事件的回调机制，对于不同事件的发生，调用相应的处理函数**

### 数据持久化

**AOF**

<img src="assets/image-20200920233557291.png" alt="image-20200920233557291" style="zoom:50%;" />

后写日志两大优点

1. 先让系统执行以下命令，如果成功则写入文件，如果失败，直接抛出异常。
2. 在命令执行后才记录日志，不会阻塞当前的写操作。

> 因为这个机制，在使用的时候可能时候系统的性能瓶颈，如果写入磁盘较慢，可能给下一个操作带来阻塞风险，AOF日志也是在主线程中执行的，如果把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行。
>
> 注意AOF文件过大带来的性能影响。



针对上述的问题，AOF增加配置项appendfsync配置项解决。

<img src="assets/image-20200920234430045.png" alt="image-20200920234430045" style="zoom:50%;" />



**文件过大带来的性能问题**

1. 重写AOF日志文件
2. 

**RDB**

- short name for:  Redis DataBase
- 提供两个命令生成RDB文件，分别是save和bgsave命令
  - save，在主线程中执行，会导致阻塞
  - bgsave，创建一个子线程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis  RDB文件生成的默认配置。
- 





### repl_backlog_buffer和replication buffer理解

1. repl_backlog_buffer：就是上面我解释到的，它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量同步带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量同步，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量同步的概率。而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。
2. replication buffer：Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer。
3. 既然有这个内存buffer存在，那么这个buffer有没有限制呢？如果主从在传播命令时，因为某些原因从库处理得非常慢，那么主库上的这个buffer就会持续增长，消耗大量的内存资源，甚至OOM。所以Redis提供了client-output-buffer-limit参数限制这个buffer的大小，如果超过限制，主库会强制断开这个client的连接，也就是说从库处理慢导致主库内存buffer的积压达到限制后，主库会强制断开从库的连接，此时主从复制会中断，中断后如果从库再次发起复制请求，那么此时可能会导致恶性循环，引发复制风暴，这种情况需要格外注意。

