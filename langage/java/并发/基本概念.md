### 为了合理利用CPU的高性能，平衡IO/CPU/内存的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：
  - CPU增加了缓存，以均衡与内存的速度差异；
  - 操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；
  - 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

- 一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为```可见性```
- 我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为```原子性```
- 缓存导致的可见性问题，线程切换带来的原子性问题，编译优化带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。

### 同时上诉优化也带来如下问题
- 缓存导致的可见性问题
- 线程切换带来的原子性问题
  - 出现IO阻塞时会出现线程切换
  - 在一个时间片内，如果一个进程进行一个IO操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让CPU的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。
- 编译优化带来的有序性问题

### new对象操作步骤
``` java
Singleton instance =new Singleton()
```
- 分配一块内存M；
- 将M的地址赋值给instance变量；
- 最后在内存M上初始化Singleton对象。
对于CPU来说的三个指令
这一行分对于CPU来讲，有3个指令：
1. 分配内存空间
2. 初始化对象
3. instance引用指向内存空间
### 问题思考
- long类型64位，所以在32位的机器上，对long类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题