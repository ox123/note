go fmt

go get   download dependency

go install 

go list

```go

```

```go
for index, char := range myString {
...
}
for key, value := range MyMap {
...
}
for index, value := range MyArray {
...
}
```

##### 接口

接口定义一组方法集合  

```go
type IF interface {  
Method1(param_list) return_type  
}
```

• 适用场景：Kubernetes 中有大量的接口抽象和多种实现  
• Struct 无需显示声明实现 interface，只需直接实现方法  
• Struct 除实现 interface 定义的接口外，还可以有额外的方法  
• 一个类型可实现多个接口（Go 语言的多重继承）  
• Go 语言中接口不接受属性定义  
• 接口可以嵌套其他接口

##### 反射

reflect.TypeOf ()返回被检查对象的类型  
• reflect.ValueOf()返回被检查对象的值  
• 示例  

```go
myMap := make(map[string]string, 10)  
myMap["a"] = "b"  
t := reflect.TypeOf(myMap)  
fmt.Println("type:", t)  
v := reflect.ValueOf(myMap)  
fmt.Println("value:", v)
```

### JSON编解码

-  json 包使用 map[string]interface{} 和 []interface{} 类型保存任意对象  

-  可通过如下逻辑解析任意 json  

- interface{} 可以是任意类型

```go

```

##### 错误处理

Go 语言无内置 exceptio 机制，只提供 error 接口供定义错误  

```go
type error interface {  
Error() string  
}
```

• 可通过 errors.New 或 fmt.Errorf 创建新的 error  
• var errNotFound error = errors.New("NotFound")  
• 通常应用程序对 error 的处理大部分是判断 error 是否为 nil  
如需将 error 归类，通常交给应用程序自定义，比如 kubernetes 自定义了与 apiserver 交互的不同类型错误  

```go
type StatusError struct {  
ErrStatus metav1.Status  
}  
var _ error = &StatusError{}
```

##### defer

函数返回之前执行某个语句或函数  
• 等同于 Java 和 C# 的 finally  
• 常见的 defer 使用场景：记得关闭你打开的资源  
• defer file.Close()  
• defer mu.Unlock()  
• defer println("")



##### Panic 和recover

- panic: 可在系统出现不可恢复错误时主动调用 panic, panic 会使当前线程直接 crash

- defer: 保证执行并把控制权交还给接收到 panic 的函数调用者  

- recover: 函数从 panic 或 错误场景中恢复  

```go
 	defer func() {
		fmt.Println("defer func is called")
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()
	panic("a panic is triggered") 

```


