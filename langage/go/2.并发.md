### 并行与并发

- 并行：同时发生
- 并发：交替发



### 进程状态

1. 初始状态、就绪状态、运行状态，挂起与终止状态



1. 线程：LWP 轻量级的进程，最小的执行单位，cpu分配时间轮片的单位
2. 进程： 系统资源调度的最小单位，由独立的 PCB，



协程： 轻量级线程，未提高执行效率

### godoc: https://studygolang.com/pkgdoc

### goroutine go程

- 创建与进程中，直接使用go关键字，放置于函数调用前面，产生一个go程
- 主go程结束，子go程随之推出。

### runtime 

- ```go
  func Gosched()
  ```

  Gosched使当前go程放弃处理器，以让其它go程运行。它不会挂起当前go程，因此当前go程未来会恢复执行。再次获取cpu时，从出让位置开始继续执行

- ```go
  func Goexit() // 结束调用该函数的go程，之前注册的go程还是生效的
  return // 
  ```

- ```go
  defer //类似java的addHock 钩子函数，在程序结束前回收资源调用。
  ```

- ```go
  runtime.GOMAXPROCS(4) // 设置go程cpu核数
  ```




### channel

- 是一个数据类型，主要用来解决协程的同步问题以及gon程之间数据共享（数据传递）的问题
- goroutine通过通信来共享内存，而不是共享内存来通信。

---

1. 数据没发送完，不应该关闭

2. 已经关闭的channel，不能再向其写入数据，报错：panic: send on closed channel

3. 写端已经关闭的channel，可以从中读去数据。读取的数据为0；如果读取数据为0，则写端关闭

   - 读无缓冲channel： 读取0， 说明写段关闭
   - 读有缓冲channel，如果缓冲区有数据，先读取其数据，读取后可以继续读，但是读取到的值为0.

4. 判断缓冲中是否关闭

   ```go
   if num, ok := <- ch; ok == true { // 可以使用range语法替换
   			fmt.Println("读到数据：", num)
   		} else {
   			n := <- ch
   			fmt.Println("关闭后：", n)
   			break
   }
   // 另外一种遍历方式
   for num: range ch{
       fmt.Println(num)
   }
   ```

---

- 单向写channel： var sendCh chan <- int
- 单向读channel： var recvCh <- chan int
- 转换
  - 双向的channel可以转换为任意一种单项channel
  - 单向channel不能转换为双向的channel

### 生产者与消费者

```go
import "fmt"

func producer(out chan<- int) {
	for i := 0; i < 10; i++ {
		out <- i * i
	}
	close(out)
}

func consumer(in <-chan int) {
	for num := range in {
		fmt.Println(num)
	}

}
func main() {
	ch := make(chan int)
	go producer(ch)
	consumer(ch)
}
```



### 定时器

- timer 指定定时时长，定时到达后，系统会自动向定时器中的C写入当前的时间。读取timer.C获取定时之后的系统时间，并且完成一次chan的读操作
- 三种定时器方法

```go
func main() {
	// 第一种方法
	//time.Sleep(time.Second)

	// 第二种方法
	fmt.Println(time.Now())
	mytimer := time.NewTimer(time.Second * 2) // 创建定时器
	fmt.Println(<-mytimer.C)
	// 第三种
	nowTime := <-time.After(time.Second *2)
	fmt.Print(nowTime)
}
```

- 周期定时

  ```go
  fmt.Println("now:",time.Now())
  myTicker := time.NewTicker(time.Second *2)
  go func() {
      for  {
          nowTime := <- myTicker.C
          fmt.Println("-->",nowTime)
      }
  }()
  for  {
      ;
  }
  ```

  

- 

### select语句

- case中必须时一个io操作

- demo

  ```go
  package main
  
  import (
  	"fmt"
  	"time"
  	"runtime"
  )
  
  func main()  {
  	ch := make(chan int)			// 用来进行数据通信的 channel
  	quit := make(chan bool)			// 用来判断是否退出的 channel
  	//ch2 := make(chan string)
  	go func() {					// 写数据
  		for i:=0; i<5;i++{
  			ch <- i
  			time.Sleep(time.Second)
  		}
  		close(ch)
  		quit <- true			// 通知主go程 退出
  		runtime.Goexit()
  	}()
  	for {						// 主go程 select 监听 chan数据流动
  		select {
  		case num := <-ch:		// 不可读，阻塞。可以读，将数据保存至num
  			fmt.Println("读到：", num)		// 模拟使用数据
  
  		case <-quit:			// 不可读，阻塞。可以读，将主go程结束。
  			break 				// break 跳出 select	不可用
  			//runtime.Goexit()	// 终止 主 go 程		不可用
  			//return 				// 终止进程
  		}
  		fmt.Println("============")		// select 自身不带有循环机制，需借助外层 for 来循环监听
  	}
  }
  
  ```

  

- 