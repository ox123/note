- 一个 znode 节点 可以包含子 znode，同时也可以包含数据，但是 znode 只 
  适合存储非常小量的数据，不能超过 1M，最好小于 1K

ZooKeeper

一、概述

ZooKeeper：解决分布式系统当中的一些业务协调的问题

三篇论文中都提到一个共同点：
    分布式锁：chubby

（一）命名空间
    linux系统 / 
    /home/hadoop/hadoopdata/abc.txt
    ZooKeeper：
    /home/hadoop/hadoopdata/abc.txt
        1、可以存储数据
        2、可以挂载数据
    Znode
            Znode只能存储非常小量的数据
    每一个节点都有一个唯一的绝对路径。
    1、ZooKeeper的文件系统的节点叫做Znode，不叫做file或文件夹，znode具有文件和文件夹的功能
    2、ZooKeeper的每个znode节点不能存储大量的数据，只适合存储非常小的关键性的数据。
    3、每个接地那都可以存储数据，格式可以看成Map
        key：节点的绝对路径
        value：就是该znode节点存储的数据

（二）Znode的分类：
    分两类：
        1、持久节点 persistent znode

        2、临时/短暂节点 ephemeral znode  
    
        不管是什么节点，都是有一个特定的会话创建连接的，这个会话就是session
    
        区别：
            1、临时节点的删除会随着session得断开自动删除
            2、临时节点下面不能再有其他的子节点
    
        分成四类：
            1、持久节点 persistent znode
                （1）带顺序编号的持久节点
                （2）不带顺序编号的持久节点
    
            不带顺序编号的持久节点
            create /hadoop "hello"
    
            带顺序编号的持久节点
            create -s /hadoop "hello"
                hadoop_0001
    
            2、临时/短暂节点 ephemeral znode 
                （1）带顺序编号的临时节点
                （2）不带顺序编号的临时节点

（三）监听机制

        1、发送请求，网ZooKeeper系统的某个节点注册一个监听
        2、当ZooKeeper集群系统知道监听的数据节点发生了事件变化之后，就发送响应给客户端
    
    
        三个非常重要的组成部分：
        客户端线程、WatcherManage、ZooKeeper服务器
    
    
        ZooKeeper 的 Watcher 机制主要包括客户端线程、客户端 WatcherManager、
        Zookeeper 服务 器三部分。客户端在向 ZooKeeper 服务器注册的同时，
        会将 Watcher 对象存储在客户端的 WatcherManager 当中。
        当 ZooKeeper 服务器触发 Watcher 事件后，会向客户端发送通知，客户端线 
        程从 WatcherManager 中取出对应的 Watcher 对象来执行回调逻辑。
    
        1、拿连接，注册监听
        2、ZooKeeper系统等待该节点的一些事件
        3、客户端接收到事件的通知以后，会自动调用回调的代码
    
    
        两个名词：
            事件     
            触发事件 
    
     举个例子：
        节点的变化：
        1、节点下面存的值发送变化 
        2、 这个节点可能被删除 
        3、这个节点下面可以增加或减少子节点
    
        创建监听：
            //拿到连接
            ZooKeeper zk = new ZooKeeper();
            //注册监听
            zk.exists("/zk/c1") //判断某节点是否存在
            zk.exists("/zk/c1",watch) //判断某节点是否存在  注册监听
    
            Watcher watch = new Watcher(){
                //回调方法
                process(){
                    //回调的业务逻辑
    
                    if
                }
            }
    
        高级功能：根据对应的节点的一些变化，知道发生了什么事情，
        然后再去回调一些对应的业务逻辑代码。
    
        补充一点：    
            监听机制只生效一次，怎么样做到循环监听？

二、应用场景
    1、命名服务
        namespace 名称空间
        名称空间里面的数据在，我们抽象目录树就在
        naming 命名服务

        只要能够在ZooKeeper文件系统当中创建成功一个节点，那么该命名就成功了。
    2、配置管理
        给所有的配置信息放到ZooKeeper的系统里面去，让其他节点监控加了配置信息的节点，只要这个配置信息发送了变化，其他节点就都能收到通知。
        只要能收到通知，给监控节点上面的配置信息查过来然后替换。
    3、集群管理
        分为两大类：
        1、管理主节点
            解决单点故障的时候，能够做到迅速的切换并选择主
        2、管理从节点
        做到实时感知节点的变化
    4、分布式锁
        1、读锁  共享锁  
        2、写锁 独占锁/排它锁
        3、时序锁
    5、队列管理
        (1)FIFO
            队列按照FIFO进行入队和出队操作
        (2)同步队列
            当一个队列当中的所有的成员都聚齐了以后，这个队列才可以使用，否则一直等待所有的成员到达。
    讲了这么多场景，基本上和创建节点、删除节点是不是都有关系。
    不管是创建节点还是删除节点，都要通过监听机制发送给客户端
    
    znode系统
    监听机制
    
    
    休息10分钟 21:35左右上课！！

三、ZooKeeper的架构
    ZooKeeper也是一种主从架构
    hdfs是主从架构

    1、首先要有一个算法
    2、原来的主节点宕机以后，集群要能够立马重新的去选举一个新的主节点
    
    standby namenode要和 active namenode的状态必须时刻保持一致。
    
    在ZooKeeper当中，集群中的所有节点的状态都是一模一样的。
    ZooKeeper能够正常对外提供服务的最低要求：宕机的节点个数不超过半数
    
    ZooKeeper当中的节点到底是越多越好？还是越少越好？
    ZooKeeper集群的个数不宜太多，也不宜太少
    ZooKeeper集群当中的每个节点的状态都一模一样
    ZooKeeper的所有节点的数据都必须保持同步
    
    
    总结一下：
    ZooKeeper也是主从架构，有主节点，主节点挂了之后，要进行选举。所有的节点的状态要一模一样
    所有的节点的数据都要保持一致，每个ZooKeeper节点当中都保持了一份完整的znode系统的数据
    
    所有的客户端无论连接到ZooKeeper集群中的那个节点，都能读取到znode系统当中的最新的数据
    
    假如有一个写数据的请求发送到了node1节点上，但是有一个读数据的请求发送到了node2节点，是不是必须要让node2从node1上读取最新的数据
    
    ZAB 原子广播协议
    
    node10接收到一条写数据请求，会转发到写数据请求到主节点 node1
    主节点就是用来控制ZooKeeper系统的全局事务的（事务编号 zxid 全局递增的）。
    这个全局事务通过zab协议控制
    最终的效果：成功接收主节点的数据同步请求，其他节点顺利修改成最新的数值。
                没有接收到的节点，给它剔除服务范围。
    
    读数据，随便连接到哪个节点都可以，写数据请求不一样，从节点接收到请求之后要转发给主节点。
    
    zxid： ZooKeeper Transaction id
    
    
    
    集群中的角色：
    1、observer
    （1）observer和follower几乎是一致的。除了没有选举权和被选举权
    （2）为了让ZooKeeper集群压力过大的时候进行压力分担
    
    ZooKeeper当中有四个角色：
    Leader：当前集群中的主节点
    Follower：从节点
    Observer：观察点 
    Client：客户端
    
    ZooKeeper的设计目的
    1、 最终一致性：
        Client不论连接到哪个节点，展示给它的都是一个完整的znode视图
    
    2、 可靠性：
        如果消息m被一台服务器所以接收，那么它将会被所有的服务器接收。
    
    3、 实时性：
        其实为了保证系统的可靠性，让数据报纸一致性，最好是实时的。
    
    4、 等待无关（wait-free）：
        慢的或者失效的客户端是不能干扰快速的客户端的请求的。
        排队！
    
    5、 原子性：
        更新只能成功或者失败，没有中间状态。
    
    6、顺序性
        设计这个ZooKeeper的时候，顺序性是必须保证的。
        （1）局部有序  偏序
        （2）全局有序
            如果一个请求a在请求b先到达某个服务器，那么其他的所有的服务器的执行顺序都是a早于b
            先来后到
    
    ZooKeeper的选举两种情况：
    1、完全全新的集群
        标准：每个节点都有一个对应的serverid，就是一个1-255之间的数值，不能重复
        在全新集群中的选举中非常重要：谁的serverid大，谁胜出
    2、不是完全全新的集群
        因素：  （1）数据版本
                （2）全局时钟
                （3）serverid
    ZooKeeper集群的节点个数，一般来说都是奇数
    
    选举算法：
        集群当中的节点超过半数同意，就能选举出leader。也就是说:少数服从多数
        在选举leader的时候，只有follower来进行选择
        总共的follower的个数是奇数个。
    
        选举的半数设置是以为配置文件中的这个follower的个数来决定的。并不是follower宕机之后的剩余的节点的半数。

四、集群搭建
    文档

五、shell和Java APi操作
    shell操作自己去完成
    Java API代码也是自己完成。我提供一个参考

六、底层算法
    Paxos算法：
    Paxos算法一种基于消息传递并且具有高度容错性特性的一致性算法。

    在Paxos算法当中有三种角色：
    1、决议（value）只有被提议者提出之后才能批准
    2、在一次的Paxos算法的执行实例当中，只能批准一个value
    3、learner只能获得被批准的value
    
    Paxos算法工作原理：
    1、所有的事务请求都必须有一个全局唯一的服务器来进行协调，这个服务器就被称之为leader服务器；剩下的就是follower服务器
    2、leader服务器负责将客户端的请求转换成一个事务进行提案，并将改提案分发给所有的集群中的follower服务器。
    3、leader服务器需要等待所有的follower服务器的反馈
    4、一旦超过半数的follower服务器进行了正确的反馈，那么leader就会再次向所有的follower服务器分发消息，要求将上面的提案进行提交。
